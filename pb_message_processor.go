package main

import (
	"errors"
	"fmt"
	"github.com/carbonblack/cb-event-forwarder/sensor_events"
	"github.com/golang/protobuf/proto"
	"strings"
)

func GetProcessGUID(m *sensor_events.CbEventMsg) string {
	if m.Header.ProcessPid != nil && m.Header.ProcessCreateTime != nil && m.Env != nil &&
		m.Env.Endpoint != nil && m.Env.Endpoint.SensorId != nil {
		pid := m.Header.GetProcessPid()
		create_time := m.Header.GetProcessCreateTime()
		sensor_id := m.Env.Endpoint.GetSensorId()

		return MakeGUID(sensor_id, pid, create_time)
	} else {
		return fmt.Sprintf("%d", m.Header.GetProcessGuid())
	}
}

type ConvertedCbMessage struct {
	OriginalMessage *sensor_events.CbEventMsg
}

func (inmsg *ConvertedCbMessage) getStringByGuid(guid int64) (string, error) {
	for _, rawString := range inmsg.OriginalMessage.GetStrings() {
		if rawString.GetGuid() == guid {
			return GetUnicodeFromUTF8(rawString.GetUtf8String()), nil
		}
	}
	return "", errors.New(fmt.Sprintf("Could not find string for id %d", guid))
}

func ProcessProtobufMessage(routingKey string, body []byte) (map[string]interface{}, error) {
	cbMessage := new(sensor_events.CbEventMsg)
	err := proto.Unmarshal(body, cbMessage)
	if err != nil {
		return nil, err
	}

	inmsg := &ConvertedCbMessage{
		OriginalMessage: cbMessage,
	}

	outmsg := make(map[string]interface{})
	outmsg["timestamp"] = WindowsTimeToUnixTime(inmsg.OriginalMessage.Header.GetTimestamp())
	outmsg["type"] = routingKey

	outmsg["sensor_id"] = cbMessage.Env.Endpoint.GetSensorId()
	outmsg["computer_name"] = cbMessage.Env.Endpoint.GetSensorHostName()

	// is the message from an endpoint event process?
	eventMsg := true

	switch {
	case cbMessage.Process != nil:
		WriteProcessMessage(inmsg, outmsg)
	case cbMessage.Modload != nil:
		WriteModloadMessage(inmsg, outmsg)
	case cbMessage.Filemod != nil:
		WriteFilemodMessage(inmsg, outmsg)
	case cbMessage.Network != nil:
		WriteNetconnMessage(inmsg, outmsg)
	case cbMessage.Regmod != nil:
		WriteRegmodMessage(inmsg, outmsg)
	case cbMessage.Childproc != nil:
		WriteChildprocMessage(inmsg, outmsg)
	case cbMessage.Module != nil:
		eventMsg = false
		WriteModinfoMessage(inmsg, outmsg)
	default:
		return nil, errors.New("Unknown event type encountered")
	}

	// write metadata about the process in case this message is generated by a process on an endpoint
	if eventMsg {
		outmsg["process_guid"] = GetProcessGUID(cbMessage)
		outmsg["pid"] = inmsg.OriginalMessage.Header.GetProcessPid()
		if _, ok := outmsg["md5"]; !ok {
			outmsg["md5"] = GetMd5Hexdigest(inmsg.OriginalMessage.Header.GetProcessMd5())
		}
	}

	return outmsg, nil
}

func WriteProcessMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "proc"

	file_path, _ := message.getStringByGuid(message.OriginalMessage.Header.GetFilepathStringGuid())
	kv["path"] = file_path

	// hack to rewrite the "type" since the Cb server may make incoming process events "ingress.event.process" or
	// "ingress.event.procstart"

	if message.OriginalMessage.Process.GetCreated() {
		kv["type"] = "ingress.event.procstart"
		if message.OriginalMessage.Process.Md5Hash != nil {
			kv["md5"] = GetMd5Hexdigest(message.OriginalMessage.Process.GetMd5Hash())
		}
	} else {
		kv["type"] = "ingress.event.procend"
	}

	kv["command_line"] = GetUnicodeFromUTF8(message.OriginalMessage.Process.GetCommandline())

	om := message.OriginalMessage
	kv["parent_process_guid"] = MakeGUID(om.Env.Endpoint.GetSensorId(), om.Process.GetParentPid(),
		om.Process.GetParentCreateTime())

	if message.OriginalMessage.Process.Username != nil {
		kv["username"] = message.OriginalMessage.Process.GetUsername()
	}
}

func WriteModloadMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "modload"

	file_path, _ := message.getStringByGuid(message.OriginalMessage.Header.GetFilepathStringGuid())
	kv["path"] = file_path
	kv["md5"] = GetMd5Hexdigest(message.OriginalMessage.Modload.GetMd5Hash())

}

func filemodAction(a sensor_events.CbFileModMsg_CbFileModAction) string {
	switch a {
	case sensor_events.CbFileModMsg_actionFileModCreate:
		return "create"
	case sensor_events.CbFileModMsg_actionFileModWrite:
		return "write"
	case sensor_events.CbFileModMsg_actionFileModDelete:
		return "delete"
	case sensor_events.CbFileModMsg_actionFileModLastWrite:
		return "lastwrite"
	}
	return fmt.Sprintf("unknown (%d)", int32(a))
}

func WriteFilemodMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "filemod"

	file_path, _ := message.getStringByGuid(message.OriginalMessage.Header.GetFilepathStringGuid())
	kv["path"] = file_path

	action := message.OriginalMessage.Filemod.GetAction()
	kv["action"] = filemodAction(action)
	kv["actiontype"] = int32(action)
}

func WriteChildprocMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "childproc"

	kv["created"] = message.OriginalMessage.Childproc.GetCreated()

	om := message.OriginalMessage
	if om.Childproc.Pid != nil && om.Childproc.CreateTime != nil && om.Env != nil &&
		om.Env.Endpoint != nil && om.Env.Endpoint.SensorId != nil {
		pid := om.Childproc.GetPid()
		create_time := om.Childproc.GetCreateTime()
		sensor_id := om.Env.Endpoint.GetSensorId()

		// for some reason, the Childproc.pid field is an int64 and not an int32 as it is in the process header
		// convert the pid to int32
		pid32 := int32(pid & 0xffffffff)

		kv["child_process_guid"] = MakeGUID(sensor_id, pid32, create_time)
	} else {
		kv["child_process_guid"] = om.Childproc.GetChildGuid()
	}

	kv["md5"] = GetMd5Hexdigest(message.OriginalMessage.Childproc.GetMd5Hash())
}

func regmodAction(a sensor_events.CbRegModMsg_CbRegModAction) string {
	switch a {
	case sensor_events.CbRegModMsg_actionRegModCreateKey:
		return "createkey"
	case sensor_events.CbRegModMsg_actionRegModWriteValue:
		return "writeval"
	case sensor_events.CbRegModMsg_actionRegModDeleteKey:
		return "delkey"
	case sensor_events.CbRegModMsg_actionRegModDeleteValue:
		return "delval"
	}
	return fmt.Sprintf("unknown (%d)", int32(a))
}

func WriteRegmodMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "regmod"

	kv["path"] = GetUnicodeFromUTF8(message.OriginalMessage.Regmod.GetUtf8Regpath())

	action := message.OriginalMessage.Regmod.GetAction()
	kv["action"] = regmodAction(action)
	kv["actiontype"] = int32(action)
}

func WriteNetconnMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "netconn"

	kv["domain"] = GetUnicodeFromUTF8(message.OriginalMessage.Network.GetUtf8Netpath())
	kv["ipv4"] = GetIPv4Address(message.OriginalMessage.Network.GetIpv4Address())
	kv["port"] = ntohs(uint16(message.OriginalMessage.Network.GetPort()))
	kv["protocol"] = int32(message.OriginalMessage.Network.GetProtocol())

	if message.OriginalMessage.Network.GetOutbound() {
		kv["direction"] = "outbound"
	} else {
		kv["direction"] = "inbound"
	}
}

func WriteModinfoMessage(message *ConvertedCbMessage, kv map[string]interface{}) {
	kv["event_type"] = "binary_info"
	kv["md5"] = strings.ToUpper(string(message.OriginalMessage.Module.GetMd5()))
	kv["size"] = message.OriginalMessage.Module.GetOriginalModuleLength()

	digsigResult := make(map[string]interface{})
	digsigResult["result"] = message.OriginalMessage.Module.GetUtf8_DigSig_Result()

	kv["digsig"] = digsigResult
}

// TODO: WriteCrossprocMessage
// TODO: WriteTamperMessage
// TODO: WriteProcessBlockedMessage
// TODO: WriteEmetMessage
// TODO: WriteNetconnBlockedMessage
